import numpy as np

import pytest

try:
    import numba
    from spikeinterface.sortingcomponents.clustering.isosplit_isocut import isocut, isosplit

    HAVE_NUMBA = True
except ImportError:
    HAVE_NUMBA = False


@pytest.mark.skipif(not HAVE_NUMBA, reason="no numba")
def test_isocut():
    if not HAVE_NUMBA:
        return

    # test cases number are generated by calling
    # the official isosplit6 C++ version 0.1.4 implementation from Jeremy Magland agust 2025

    dipscore, cutpoint = isocut(np.array([0, 1, 1, 2]))
    assert dipscore == 0.9427680482325083
    assert cutpoint == 1.0

    z = np.array(
        [
            0.3012,
            0.4709,
            0.2305,
            0.8443,
            0.1948,
            0.2259,
            0.1707,
            0.2277,
            0.4357,
            0.3111,
        ]
    )
    dipscore, cutpoint = isocut(z)
    assert np.abs(dipscore - 0.3440507) < 0.001
    assert np.abs(cutpoint - 0.26585) < 0.001

    t = np.array(
        [
            5.32339539,
            3.72514244,
            6.06074439,
            4.72039874,
            5.28503105,
            5.43523798,
            3.52389432,
            4.90105762,
            6.04214636,
            5.22912762,
            5.62638777,
            4.37264862,
            5.35692268,
            5.85697279,
            5.90419288,
            3.42153125,
            4.83902449,
            3.86442812,
            4.3487476,
            5.02337161,
            6.43031621,
            5.20781653,
            6.50916649,
            3.49466062,
            6.10005906,
            4.97149243,
            -6.68120837,
            -3.77983954,
            -4.48224226,
            -4.43533774,
            -5.28264468,
            -5.10141726,
            -4.72195037,
            -4.30517775,
            -3.61894388,
            -3.22391089,
            -4.93935508,
            -4.13938463,
            -5.71609654,
            -4.03895828,
            -4.86202822,
            -4.03284017,
            -6.78072313,
            -5.55439593,
            -4.5964243,
            -6.23230336,
            -5.28762918,
            -6.78708774,
            -4.2274206,
            -5.20307468,
            -6.86372755,
            -6.67979293,
        ]
    )
    dipscore, cutpoint = isocut(t)
    assert np.abs(dipscore - 2.8466347) < 0.001
    assert np.abs(cutpoint - 0.09881018) < 0.001


def make_nd_blob(
    dim=3,
    n_clusters=5,
    cluster_size=1000,
    seed=None,
):
    rng = np.random.default_rng(seed=seed)

    data = []
    gt_label = []
    for i in range(n_clusters):
        if isinstance(cluster_size, int):
            size = cluster_size
        elif isinstance(cluster_size, tuple):
            lim0, lim1 = cluster_size
            size = int(rng.uniform() * (lim1 - lim0) + lim0)
        else:
            raise ValueError("Bad boy")

        center = rng.uniform(size=(dim)) * 10
        # cov = rng.uniform(size=(dim, dim)) * 2
        # cov = cov + cov.T
        cov = np.eye(dim) / 5

        one_cluster = np.random.multivariate_normal(center, cov, size=size)
        data.append(one_cluster)
        gt_label.append(np.ones(size) * i)
    data = np.concatenate(data)
    gt_label = np.concatenate(gt_label)

    return data, gt_label


@pytest.mark.skipif(not HAVE_NUMBA, reason="no numba")
def test_isosplit():

    data, gt_label = make_nd_blob(
        dim=2,
        n_clusters=3,
        cluster_size=(400, 800),
        seed=2406,
    )
    data = data.astype("float64")

    labels = isosplit(data, isocut_threshold=2.0, n_init=40)
    # the beauty is that it discovers the number of clusters automatically, at least for this this seed :)
    assert np.unique(labels).size == 3

    # check that numba handle the 2 dtypes
    data = data.astype("float32")
    labels = isosplit(data, isocut_threshold=2.0, n_init=40)
    assert np.unique(labels).size == 3

    # DEBUG = True
    # if DEBUG :
    #     import matplotlib.pyplot as plt

    #     if data.shape[1] == 2:
    #         fig, ax = plt.subplots()
    #         ax.scatter(data[:, 0], data[:, 1], s=1, c=labels)
    #     else:
    #         fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))
    #         ax.scatter(data[:, 0], data[:, 1], data[:, 2], s=1, c=labels)

    #     plt.show()


if __name__ == "__main__":
    # test_isocut()
    test_isosplit()
